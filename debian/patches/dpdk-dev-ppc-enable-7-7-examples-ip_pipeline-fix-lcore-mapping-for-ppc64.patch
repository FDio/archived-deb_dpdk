From: Gowrishankar Muthukrishnan <gowrishankar.m@linux.vnet.ibm.com>
Date: Thu, 8 Sep 2016 22:18:10 +0530
Subject: [PATCH 7/7] examples/ip_pipeline: fix lcore mapping for ppc64

This patch fixes ip_pipeline panic in app_init_core_map while preparing cpu
core map in powerpc with SMT off. cpu_core_map_compute_linux currently prepares
core mapping based on file existence in sysfs ie.

/sys/devices/system/cpu/cpu<LCORE_NUM>/topology/physical_package_id
  /sys/devices/system/cpu/cpu<LCORE_NUM>/topology/core_id

These files do not exist for lcores which are offline for any reason (as in
powerpc, while SMT is off). In this situation, this function should further
continue preparing map for other online lcores instead of returning with -1
for a first unavailable lcore.

Also, in SMT=off scenario for powerpc, lcore ids can not be always indexed from
0 upto 'number of cores present' (/sys/devices/system/cpu/present). For eg, for
an online lcore 32, core_id returned in sysfs is 112 where online lcores are
10 (as in one configuration), hence sysfs lcore id can not be checked with
indexing lcore number before positioning lcore map array.

Signed-off-by: Gowrishankar Muthukrishnan <gowrishankar.m@linux.vnet.ibm.com>
Acked-by: Chao Zhu <chaozhu@linux.vnet.ibm.com>
Acked-by: Cristian Dumitrescu <cristian.dumitrescu@intel.com>

Origin: Upstream, commit:58d55fd279dc6f8f8d92fcab3362e24e19c9fbea
Author: Gowrishankar Muthukrishnan <gowrishankar.m@linux.vnet.ibm.com>
Last-Update: 2016-09-21
---
 examples/ip_pipeline/cpu_core_map.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/examples/ip_pipeline/cpu_core_map.c b/examples/ip_pipeline/cpu_core_map.c
index cb088b1..dd8f678 100644
--- a/examples/ip_pipeline/cpu_core_map.c
+++ b/examples/ip_pipeline/cpu_core_map.c
@@ -351,8 +351,10 @@ cpu_core_map_compute_linux(struct cpu_core_map *map)
 			int lcore_socket_id =
 				cpu_core_map_get_socket_id_linux(lcore_id);
 
+#if !defined(RTE_ARCH_PPC_64)
 			if (lcore_socket_id < 0)
 				return -1;
+#endif
 
 			if (((uint32_t) lcore_socket_id) == socket_id)
 				n_detected++;
@@ -368,6 +370,7 @@ cpu_core_map_compute_linux(struct cpu_core_map *map)
 					cpu_core_map_get_socket_id_linux(
 					lcore_id);
 
+#if !defined(RTE_ARCH_PPC_64)
 				if (lcore_socket_id < 0)
 					return -1;
 
@@ -377,9 +380,14 @@ cpu_core_map_compute_linux(struct cpu_core_map *map)
 
 				if (lcore_core_id < 0)
 					return -1;
+#endif
 
+#if !defined(RTE_ARCH_PPC_64)
 				if (((uint32_t) lcore_socket_id == socket_id) &&
 					((uint32_t) lcore_core_id == core_id)) {
+#else
+				if (((uint32_t) lcore_socket_id == socket_id)) {
+#endif
 					uint32_t pos = cpu_core_map_pos(map,
 						socket_id,
 						core_id_contig,
-- 
1.9.1

